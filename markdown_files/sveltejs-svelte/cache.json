{"content":"--- title: Overview --- - Short intro to what Svelte is and why it's the best ever - A few code examples to have a very rough understanding of how Svelte code looks like - Jump off points to tutorial, SvelteKit etc Svelte is a web UI framework that uses a compiler to turn declarative component code like this...  ...into tightly optimized JavaScript that updates the document when state like count changes. Because the compiler can 'see' where count is referenced, the generated code is highly efficient, and because we're hijacking syntax like `$state` and `=` instead of using cumbersome APIs, you can write less code. Besides being fun to work with, Svelte offers a lot of features built-in, such as animations and transitions. Once you've written your first components you can reach for our batteries included metaframework  which provides you with an opinionated router, data loading and more. If you're new to Svelte, visit the  before consulting this documentation. You can try Svelte online using the . Alternatively, if you'd like a more fully-featured environment, you can try Svelte on . --- title: Getting started --- - `npm create svelte@latest`, describe that it scaffolds SvelteKit project - `npm create vite@latest`, describe that it scaffolds Svelte SPA powered by Vite - mention `svelte-add` - Jump off points to tutorial, SvelteKit etc ## Start a new project We recommend using , the official application framework from the Svelte team:  SvelteKit will handle calling  to convert your `.svelte` files into `.js` files that create the DOM and `.css` files that style it. It also provides all the other pieces you need to build a web application such as a development server, routing, deployment, and SSR support.  uses  to build your code. Don't worry if you don't know Svelte yet! You can ignore all the nice features SvelteKit brings on top for now and dive into it later. ### Alternatives to SvelteKit If you don't want to use SvelteKit for some reason, you can also use Svelte with Vite  by running `npm create vite@latest` and selecting the `svelte` option. With this, `npm run build` will generate HTML, JS and CSS files inside the `dist` directory thanks using . In most cases, you will probably need to  as well. Alternatively, there are plugins for ,   to handle Svelte compilation — which will output `.js` and `.css` that you can insert into your HTML — but setting up SSR with them requires more manual work. ## Editor tooling The Svelte team maintains a  and there are integrations with various other  and tools as well. You can also check your code from the command line using  . ## Getting help Don't be shy about asking for help in the ! You can also find answers on . --- title: Reactivity fundamentals --- Reactivity is at the heart of interactive UIs. When you click a button, you expect some kind of response. It's your job as a developer to make this happen. It's Svelte's job to make your job as intuitive as possible, by providing a good API to express reactive systems. ## Runes Svelte 5 uses _runes_, a powerful set of primitives for controlling reactivity inside your Svelte components and inside `.svelte.js` and `.svelte.ts` modules. Runes are function-like symbols that provide instructions to the Svelte compiler. You don't need to import them from anywhere — when you use Svelte, they're part of the language. The following sections introduce the most important runes for declare state, derived state and side effects at a high level. For more details refer to the later sections on  and . ## `$state` Reactive state is declared with the `$state` rune:  You can also use `$state` in class fields :  ## `$derived` Derived state is declared with the `$derived` rune:  The expression inside `$derived` should be free of side-effects. Svelte will disallow state changes  inside derived expressions. As with `$state`, you can mark class fields as `$derived`. ## `$effect` To run _side-effects_ when the component is mounted to the DOM, and when values change, we can use the `$effect` rune ):  The function passed to `$effect` will run when the component mounts, and will re-run after any changes to the values it reads that were declared with `$state` or `$derived` . Re-runs are batched , and happen after any DOM updates have been applied. --- title: Introduction --- --- title: Component fundamentals --- - script  / template / style  - `$props` / `$state`  Components are the building blocks of Svelte applications. They are written into `.svelte` files, using a superset of HTML. All three sections — script, styles and markup — are optional.  ## &lt;script&gt; A `<script>` block contains JavaScript  that runs when a component instance is created. Variables declared  at the top level are 'visible' from the component's markup. ### Public API of a component Svelte uses the `$props` rune to declare _properties_ or _props_, which means describing the public interface of the component which becomes accessible to consumers of the component. > `$props` is one of several runes, which are special hints for Svelte's compiler to make things reactive.  You can specify a fallback value for a prop. It will be used if the component's consumer doesn't specify the prop on the component when instantiating the component, or if the passed value is `undefined` at some point.  To get all properties, use rest syntax:  You can use reserved words as prop names.  If you're using TypeScript, you can declare the prop types:  If you're using JavaScript, you can declare the prop types using JSDoc:  If you export a `const`, `class` or `function`, it is readonly from outside the component.  Readonly props can be accessed as properties on the element, tied to the component using . ### Reactive variables To change component state and trigger a re-render, just assign to a locally declared variable that was declared using the `$state` rune. Update expressions  and property assignments  have the same effect.  Svelte's `<script>` blocks are run only when the component is created, so assignments within a `<script>` block are not automatically run again when a prop updates.  If you'd like to react to changes to a prop, use the `$derived` or `$effect` runes instead.  For more information on reactivity, read the documentation around runes. ## &lt;script module&gt; A `<script>` tag with a `module` attribute runs once when the module first evaluates, rather than for each component instance. Values declared in this block are accessible from a regular `<script>`  but not vice versa. You can `export` bindings from this block, and they will become exports of the compiled module. You cannot `export default`, since the default export is the component itself.  ## &lt;style&gt; CSS inside a `<style>` block will be scoped to that component.  For more information regarding styling, read the documentation around . --- title: Basic markup --- -  ## Tags A lowercase tag, like `<div>`, denotes a regular HTML element. A capitalised tag, such as `<Widget>` or `<Namespace.Widget>`, indicates a _component_.  ## Attributes and props By default, attributes work exactly like their HTML counterparts.  As in HTML, values may be unquoted. <!-- prettier-ignore -->  Attribute values can contain JavaScript expressions.  Or they can _be_ JavaScript expressions.  Boolean attributes are included on the element if their value is  and excluded if it's . All other attributes are included unless their value is  .  Quoting a singular expression does not affect how the value is parsed yet, but in Svelte 6 it will: <!-- prettier-ignore -->  When the attribute name and value match , they can be replaced with `{name}`.  By convention, values passed to components are referred to as _properties_ or _props_ rather than _attributes_, which are a feature of the DOM. As with elements, `name={name}` can be replaced with the `{name}` shorthand.  _Spread attributes_ allow many attributes or properties to be passed to an element or component at once. An element or component can have multiple spread attributes, interspersed with regular ones.  > The `value` attribute of an `input` element or its children `option` elements must not be set with spread attributes when using `bind:group` or `bind:checked`. Svelte needs to be able to see the element's `value` directly in the markup in these cases so that it can link it to the bound variable. > Sometimes, the attribute order matters as Svelte sets attributes sequentially in JavaScript. For example, `<input type=\"range\" min=\"0\" max=\"1\" value={0.5} step=\"0.1\"/>`, Svelte will attempt to set the value to `1` , and then set the step to `0.1`. To fix this, change it to `<input type=\"range\" min=\"0\" max=\"1\" step=\"0.1\" value={0.5}/>`. > Another example is `<img src=\"...\" loading=\"lazy\" />`. Svelte will set the img `src` before making the img element `loading=\"lazy\"`, which is probably too late. Change this to `<img loading=\"lazy\" src=\"...\">` to make the image lazily loaded. ## Events Listening to DOM events is possible by adding attributes to the element that start with `on`. For example, to listen to the `click` event, add the `onclick` attribute to a button:  Event attributes are case sensitive. `onclick` listens to the `click` event, `onClick` listens to the `Click` event, which is different. This ensures you can listen to custom events that have uppercase characters in them. Because events are just attributes, the same rules as for attributes apply: - you can use the shorthand form: `<button {onclick}>click me</button>` - you can spread them: `<button {...thisSpreadContainsEventAttributes}>click me</button>` - component events are just  properties and don't need a separate concept Timing-wise, event attributes always fire after events from bindings . Under the hood, some event handlers are attached directly with `addEventListener`, while others are _delegated_. When using `onwheel`, `onmousewheel`, `ontouchstart` and `ontouchmove` event attributes, the handlers are  to align with browser defaults. This greatly improves responsiveness by allowing the browser to scroll the document immediately, rather than waiting to see if the event handler calls `event.preventDefault`. In the very rare cases that you need to prevent these event defaults, you should use  instead . ### Event delegation To reduce memory footprint and increase performance, Svelte uses a technique called event delegation. This means that for certain events — see the list below — a single event listener at the application root takes responsibility for running any handlers on the event's path. There are a few gotchas to be aware of: - when you manually dispatch an event with a delegated listener, make sure to set the `{ bubbles: true }` option or it won't reach the application root - when using `addEventListener` directly, avoid calling `stopPropagation` or the event won't reach the application root and handlers won't be invoked. Similarly, handlers added manually inside the application root will run _before_ handlers added declaratively deeper in the DOM , in both capturing and bubbling phases. For these reasons it's better to use the `on` function imported from `svelte/events` rather than `addEventListener`, as it will ensure that order is preserved and `stopPropagation` is handled correctly. The following event handlers are delegated: - `beforeinput` - `click` - `change` - `dblclick` - `contextmenu` - `focusin` - `focusout` - `input` - `keydown` - `keyup` - `mousedown` - `mousemove` - `mouseout` - `mouseover` - `mouseup` - `pointerdown` - `pointermove` - `pointerout` - `pointerover` - `pointerup` - `touchend` - `touchmove` - `touchstart` ## Text expressions A JavaScript expression can be included as text by surrounding it with curly braces.  Curly braces can be included in a Svelte template by using their  strings: `&lbrace;`, `&lcub;`, or `&#123;` for `{` and `&rbrace;`, `&rcub;`, or `&#125;` for `}`. If you're using a regular expression  , you'll need to wrap it in parentheses. <!-- prettier-ignore -->  The expression will be stringified and escaped to prevent code injections. If you want to render HTML, use the `{@html}` tag instead.  > Make sure that you either escape the passed string or only populate it with values that are under your control in order to prevent  ## Comments You can use HTML comments inside components.  Comments beginning with `svelte-ignore` disable warnings for the next block of markup. Usually, these are accessibility warnings; make sure that you're disabling them for a good reason.  You can add a special comment starting with `@component` that will show up when hovering over the component name in other files. html <Main name=\"Arethra\"> ` --- title: Control flow --- - if - each - await  - NOT: key  Svelte augments HTML with control flow blocks to be able to express conditionally rendered content or lists. The syntax between these blocks is the same: - `{#` denotes the start of a block - `{:` denotes a different branch part of the block. Depending on the block, there can be multiple of these - `{/` denotes the end of a block ## {#if ...}    Content that is conditionally rendered can be wrapped in an if block.  Additional conditions can be added with `{:else if expression}`, optionally ending in an `{:else}` clause.   ## {#each ...}      Iterating over lists of values can be done with an each block.  You can use each blocks to iterate over any array or array-like value — that is, any object with a `length` property. An each block can also specify an _index_, equivalent to the second argument in an `array.map` callback:  If a _key_ expression is provided — which must uniquely identify each list item — Svelte will use it to diff the list when data changes, rather than adding or removing items at the end. The key can be any object, but strings and numbers are recommended since they allow identity to persist when the objects themselves change.  You can freely use destructuring and rest patterns in each blocks.  An each block can also have an `{:else}` clause, which is rendered if the list is empty.  It is possible to iterate over iterables like `Map` or `Set`. Iterables need to be finite and static . Under the hood, they are transformed to an array using `Array.from` before being passed off to rendering. If you're writing performance-sensitive code, try to avoid iterables and use regular arrays as they are more performant. ## Other block types Svelte also provides ,  and  blocks. You can find out more about them in their respective sections. --- title: Snippets --- Better title needed? - `#snippet` - `@render` - how they can be used to reuse markup - how they can be used to pass UI content to components Snippets, and _render tags_, are a way to create reusable chunks of markup inside your components. Instead of writing duplicative code like ...  ...you can write :  Like function declarations, snippets can have an arbitrary number of parameters, which can have default values, and you can destructure each parameter. You cannot use rest parameters however. ## Snippet scope Snippets can be declared anywhere inside your component. They can reference values declared outside themselves, for example in the `<script>` tag or in `{#each ...}` blocks )...  ...and they are 'visible' to everything in the same lexical scope :  Snippets can reference themselves and each other ):  ## Passing snippets to components Within the template, snippets are values just like any other. As such, they can be passed to components as props ):  Think about it like passing content instead of data to a component. The concept is similar to slots in web components. As an authoring convenience, snippets declared directly _inside_ a component implicitly become props _on_ the component ):  Any content inside the component tags that is _not_ a snippet declaration implicitly becomes part of the `children` snippet ):   > Note that you cannot have a prop called `children` if you also have content inside the component — for this reason, you should avoid having props with that name You can declare snippet props as being optional. You can either use optional chaining to not render anything if the snippet isn't set...  ...or use an `#if` block to render fallback content:  ## Typing snippets Snippets implement the `Snippet` interface imported from `'svelte'`:  With this change, red squigglies will appear if you try and use the component without providing a `data` prop and a `row` snippet. Notice that the type argument provided to `Snippet` is a tuple, since snippets can have multiple parameters. We can tighten things up further by declaring a generic, so that `data` and `row` refer to the same type:  ## Snippets and slots In Svelte 4, content can be passed to components using . Snippets are more powerful and flexible, and as such slots are deprecated in Svelte 5. --- title: Styles & Classes --- - style scoping - `:global` - `style:` - `class:` - `--css` props Styling is a fundamental part of UI components. Svelte helps you style your components with ease, providing useful features out of the box. ## Scoped by default By default CSS inside a `<style>` block will be scoped to that component. This works by adding a class to affected elements, which is based on a hash of the component styles .  ## :global To apply styles to a single selector globally, use the `:global` modifier:  If you want to make @keyframes that are accessible globally, you need to prepend your keyframe names with `-global-`. The `-global-` part will be removed when compiled, and the keyframe will then be referenced using just `my-animation-name` elsewhere in your code.  ## :global To apply styles to a group of selectors globally, create a `:global {...}` block:  > The second example above could also be written as an equivalent `.a :global .b .c .d` selector, where everything after the `:global` is unscoped, though the nested form is preferred. ## Nested style tags There should only be 1 top-level `<style>` tag per component. However, it is possible to have a `<style>` tag nested inside other elements or logic blocks. In that case, the `<style>` tag will be inserted as-is into the DOM; no scoping or processing will be done on the `<style>` tag.  ## class:_name_   A `class:` directive provides a shorter way of toggling a class on an element.  ## style:_property_    The `style:` directive provides a shorthand for setting multiple styles on an element.  When `style:` directives are combined with `style` attributes, the directives will take precedence:  ## --style-props  You can also pass styles as props to components for the purposes of theming, using CSS custom properties. Svelte's implementation is essentially syntactic sugar for adding a wrapper element. This example:  Desugars to this:  For SVG namespace, the example above desugars into using `<g>` instead:  > Since this is an extra `<div>` , beware that your CSS structure might accidentally target this. Be mindful of this added wrapper element when using this feature. Svelte's CSS Variables support allows for easily themeable components:  So you can set a high-level theme color:  Or override it at the consumer level: --- title: Transitions & Animations --- - how to use  - when to use - global vs local - easing & motion - mention imports - key block Svelte provides different techniques and syntax for incorporating motion into your Svelte projects. ## transition:_fn_        A transition is triggered by an element entering or leaving the DOM as a result of a state change. When a block is transitioning out, all elements inside the block, including those that do not have their own transitions, are kept in the DOM until every transition in the block has been completed. The `transition:` directive indicates a _bidirectional_ transition, which means it can be smoothly reversed while the transition is in progress.  Transitions are local by default. Local transitions only play when the block they belong to is created or destroyed, _not_ when parent blocks are created or destroyed.  > By default intro transitions will not play on first render. You can modify this behaviour by setting `intro: true` when you  and marking the transition as `global`. ## Transition parameters Transitions can have parameters.   ## Custom transition functions Transitions can use custom functions. If the returned object has a `css` function, Svelte will create a CSS animation that plays on the element. The `t` argument passed to `css` is a value between `0` and `1` after the `easing` function has been applied. _In_ transitions run from `0` to `1`, _out_ transitions run from `1` to `0` — in other words, `1` is the element's natural state, as though no transition had been applied. The `u` argument is equal to `1 - t`. The function is called repeatedly _before_ the transition begins, with different `t` and `u` arguments.  A custom transition function can also return a `tick` function, which is called _during_ the transition with the same `t` and `u` arguments. > If it's possible to use `css` instead of `tick`, do so — CSS animations can run off the main thread, preventing jank on slower devices.  If a transition returns a function instead of a transition object, the function will be called in the next microtask. This allows multiple transitions to coordinate, making  possible. Transition functions also receive a third argument, `options`, which contains information about the transition. Available values in the `options` object are: - `direction` - one of `in`, `out`, or `both` depending on the type of transition ## Transition events An element with transitions will dispatch the following events in addition to any standard DOM events: - `introstart` - `introend` - `outrostart` - `outroend`  ## in:_fn_/out:_fn_             Similar to `transition:`, but only applies to elements entering  or leaving  the DOM. Unlike with `transition:`, transitions applied with `in:` and `out:` are not bidirectional — an in transition will continue to 'play' alongside the out transition, rather than reversing, if the block is outroed while the transition is in progress. If an out transition is aborted, transitions will restart from scratch.  ## animate:_fn_     An animation is triggered when the contents of a  are re-ordered. Animations do not run when an element is added or removed, only when the index of an existing data item within the each block changes. Animate directives must be on an element that is an _immediate_ child of a keyed each block. Animations can be used with Svelte's  or .  ## Animation Parameters As with actions and transitions, animations can have parameters.   ## Custom animation functions Animations can use custom functions that provide the `node`, an `animation` object and any `parameters` as arguments. The `animation` parameter is an object containing `from` and `to` properties each containing a  describing the geometry of the element in its `start` and `end` positions. The `from` property is the DOMRect of the element in its starting position, and the `to` property is the DOMRect of the element in its final position after the list has been reordered and the DOM updated. If the returned object has a `css` method, Svelte will create a CSS animation that plays on the element. The `t` argument passed to `css` is a value that goes from `0` and `1` after the `easing` function has been applied. The `u` argument is equal to `1 - t`. The function is called repeatedly _before_ the animation begins, with different `t` and `u` arguments. <!-- TODO: Types -->  A custom animation function can also return a `tick` function, which is called _during_ the animation with the same `t` and `u` arguments. > If it's possible to use `css` instead of `tick`, do so — CSS animations can run off the main thread, preventing jank on slower devices.  ## {#key ...}  Key blocks destroy and recreate their contents when the value of an expression changes. This is useful if you want an element to play its transition whenever a value changes.  When used around components, this will cause them to be reinstantiated and reinitialised. --- title: Actions --- - template syntax - how to write - typings - adjust so that `$effect` is used instead of update/destroy?    Actions are functions that are called when an element is created. They can return an object with a `destroy` method that is called after the element is unmounted:  An action can have a parameter. If the returned value has an `update` method, it will be called immediately after Svelte has applied updates to the markup whenever that parameter changes. > Don't worry that we're redeclaring the `foo` function for every component instance — Svelte will hoist any functions that don't depend on local state out of the component definition.  ## Attributes Sometimes actions emit custom events and apply custom attributes to the element they are applied to. To support this, actions typed with `Action` or `ActionReturn` type can have a last parameter, `Attributes`: --- title: Bindings --- - how for dom elements - list of all bindings - how for components Most of the time a clear separation between data flowing down and events going up is worthwhile and results in more robust apps. But in some cases - especially when interacting with form elements - it's more ergonomic to declare a two way binding. Svelte provides many element bindings out of the box, and also allows component bindings. ## bind:_property_ for elements  Data ordinarily flows down, from parent to child. The `bind:` directive allows data to flow the other way, from child to parent. Most bindings are specific to particular elements. The simplest bindings reflect the value of a property, such as `input.value`.  If the name matches the value, you can use a shorthand.  Numeric input values are coerced; even though `input.value` is a string as far as the DOM is concerned, Svelte will treat it as a number. If the input is empty or invalid , the value is `undefined`.  On `<input>` elements with `type=\"file\"`, you can use `bind:files` to get the . It is readonly.  If you're using `bind:` directives together with `on:` directives, the order that they're defined in affects the value of the bound variable when the event handler is called.  Here we were binding to the value of a text input, which uses the `input` event. Bindings on other elements may use different events such as `change`. ## Binding `<select>` value A `<select>` value binding corresponds to the `value` property on the selected `<option>`, which can be any value .  A `<select multiple>` element behaves similarly to a checkbox group. The bound variable is an array with an entry corresponding to the `value` property of each selected `<option>`.  When the value of an `<option>` matches its text content, the attribute can be omitted.  Elements with the `contenteditable` attribute support the following bindings: -  -  -  There are slight differences between each of these, read more about them . <!-- for some reason puts the comment and html on same line --> <!-- prettier-ignore -->  `<details>` elements support binding to the `open` property.  ## Media element bindings Media elements  have their own set of bindings — seven _readonly_ ones... - `duration`  — the total duration of the video, in seconds - `buffered`  — an array of `{start, end}` objects - `played`  — ditto - `seekable`  — ditto - `seeking`  — boolean - `ended`  — boolean - `readyState`  — number between  0 and 4 ...and five _two-way_ bindings: - `currentTime` — the current playback time in the video, in seconds - `playbackRate` — how fast or slow to play the video, where 1 is 'normal' - `paused` — this one should be self-explanatory - `volume` — a value between 0 and 1 - `muted` — a boolean value indicating whether the player is muted Videos additionally have readonly `videoWidth` and `videoHeight` bindings.  ## Image element bindings Image elements  have two readonly bindings: - `naturalWidth`  — the original width of the image, available after the image has loaded - `naturalHeight`  — the original height of the image, available after the image has loaded  ## Block-level element bindings Block-level elements have 4 read-only bindings, measured using a technique similar to : - `clientWidth` - `clientHeight` - `offsetWidth` - `offsetHeight`  ## bind:group  Inputs that work together can use `bind:group`.  > `bind:group` only works if the inputs are in the same Svelte component. ## bind:this  To get a reference to a DOM node, use `bind:this`.  Components also support `bind:this`, allowing you to interact with component instances programmatically.   > Note that we can't do `{cart.empty}` since `cart` is `undefined` when the button is first rendered and throws an error. ## bind:_property_ for components  You can bind to component props using the same syntax as for elements.  While Svelte props are reactive without binding, that reactivity only flows downward into the component by default. Using `bind:property` allows changes to the property from within the component to flow back up out of the component. To mark a property as bindable, use the `$bindable` rune:  Declaring a property as bindable means it _can_ be used using `bind:`, not that it _must_ be used using `bind:`. Bindable properties can have a fallback value:  This fallback value _only_ applies when the property is _not_ bound. When the property is bound and a fallback value is present, the parent is expected to provide a value other than `undefined`, else a runtime error is thrown. This prevents hard-to-reason-about situations where it's unclear which value should apply. --- title: Special elements --- -  Some of Svelte's concepts need special elements. Those are prefixed with `svelte:` and listed here. ## `<svelte:self>` The `<svelte:self>` element allows a component to include itself, recursively. It cannot appear at the top level of your markup; it must be inside an if or each block or passed to a component's slot to prevent an infinite loop.  ## `<svelte:component>`  The `<svelte:component>` element renders a component dynamically, using the component constructor specified as the `this` property. When the property changes, the component is destroyed and recreated. If `this` is falsy, no component is rendered.  ## `<svelte:element>`  The `<svelte:element>` element lets you render an element of a dynamically specified type. This is useful for example when displaying rich text content from a CMS. Any properties and event listeners present will be applied to the element. The only supported binding is `bind:this`, since the element type-specific bindings that Svelte does at build time  do not work with a dynamic tag type. If `this` has a nullish value, the element and its children will not be rendered. If `this` is the name of a   and `<svelte:element>` has child elements, a runtime error will be thrown in development mode.  Svelte tries its best to infer the correct namespace from the element's surroundings, but it's not always possible. You can make it explicit with an `xmlns` attribute:  ## `<svelte:window>`   The `<svelte:window>` element allows you to add event listeners to the `window` object without worrying about removing them when the component is destroyed, or checking for the existence of `window` when server-side rendering. Unlike `<svelte:self>`, this element may only appear at the top level of your component and must never be inside a block or element.  You can also bind to the following properties: - `innerWidth` - `innerHeight` - `outerWidth` - `outerHeight` - `scrollX` - `scrollY` - `online` — an alias for `window.navigator.onLine` - `devicePixelRatio` All except `scrollX` and `scrollY` are readonly.  > Note that the page will not be scrolled to the initial value to avoid accessibility issues. Only subsequent changes to the bound variable of `scrollX` and `scrollY` will cause scrolling. However, if the scrolling behaviour is desired, call `scrollTo` in `onMount`. ## `<svelte:document>`   Similarly to `<svelte:window>`, this element allows you to add listeners to events on `document`, such as `visibilitychange`, which don't fire on `window`. It also lets you use  on `document`. As with `<svelte:window>`, this element may only appear the top level of your component and must never be inside a block or element.  You can also bind to the following properties: - `activeElement` - `fullscreenElement` - `pointerLockElement` - `visibilityState` All are readonly. ## `<svelte:body>`  Similarly to `<svelte:window>`, this element allows you to add listeners to events on `document.body`, such as `mouseenter` and `mouseleave`, which don't fire on `window`. It also lets you use  on the `<body>` element. As with `<svelte:window>` and `<svelte:document>`, this element may only appear the top level of your component and must never be inside a block or element.  ## `<svelte:head>`  This element makes it possible to insert elements into `document.head`. During server-side rendering, `head` content is exposed separately to the main `html` content. As with `<svelte:window>`, `<svelte:document>` and `<svelte:body>`, this element may only appear at the top level of your component and must never be inside a block or element.  ## `<svelte:options>`  The `<svelte:options>` element provides a place to specify per-component compiler options, which are detailed in the . The possible options are: - `immutable={true}` — you never use mutable data, so the compiler can do simple referential equality checks to determine if values have changed - `immutable={false}` — the default. Svelte will be more conservative about whether or not mutable objects have changed - `accessors={true}` — adds getters and setters for the component's props - `accessors={false}` — the default - `namespace=\"...\"` — the namespace where this component will be used, most commonly \"svg\"; use the \"foreign\" namespace to opt out of case-insensitive attribute names and HTML-specific warnings - `customElement={...}` — the  to use when compiling this component as a custom element. If a string is passed, it is used as the `tag` option --- title: Data fetching --- Fetching data is a fundamental part of apps interacting with the outside world. Svelte is unopinionated with how you fetch your data. The simplest way would be using the built-in `fetch` method:  While this works, it makes working with promises somewhat unergonomic. Svelte alleviates this problem using the `#await` block. ## {#await ...}     Await blocks allow you to branch on the three possible states of a Promise — pending, fulfilled or rejected. In SSR mode, only the pending branch will be rendered on the server. If the provided expression is not a Promise only the fulfilled branch will be rendered, including in SSR mode.  The `catch` block can be omitted if you don't need to render anything when the promise rejects .  If you don't care about the pending state, you can also omit the initial block.  Similarly, if you only want to show the error state, you can omit the `then` block.  ## SvelteKit loaders Fetching inside your components is great for simple use cases, but it's prone to data loading waterfalls and makes code harder to work with because of the promise handling. SvelteKit solves this problem by providing a opinionated data loading story that is coupled to its router. Learn more about it . --- title: Template syntax --- --- title: State --- Svelte 5 uses _runes_, a powerful set of primitives for controlling reactivity inside your Svelte components and inside `.svelte.js` and `.svelte.ts` modules. Runes are function-like symbols that provide instructions to the Svelte compiler. You don't need to import them from anywhere — when you use Svelte, they're part of the language. This page describes the runes that are concerned with managing state in your application. ## `$state` The `$state` rune is the at the heart of the runes API. It is used to declare reactive state:  Variables declared with `$state` are the variable _itself_, in other words there's no wrapper around the value that it contains. This is possible thanks to the compiler-nature of Svelte. As such, updating state is done through simple reassignment. You can also use `$state` in class fields :  > In this example, the compiler transforms `done` and `text` into `get`/`set` methods on the class prototype referencing private fields Objects and arrays are made deeply reactive by wrapping them with . What that means is that in the following example, we can mutate the `entries` object and the UI will still update - but only the list item that is actually changed will rerender:  > Only POJOs  are made deeply reactive. Reactivity will stop at class boundaries and leave those alone ## `$state.raw` State declared with `$state.raw` cannot be mutated; it can only be _reassigned_. In other words, rather than assigning to a property of an object, or using an array method like `push`, replace the object or array altogether if you'd like to update it:  This can improve performance with large arrays and objects that you weren't planning to mutate anyway, since it avoids the cost of making them reactive. Note that raw state can _contain_ reactive state . ## `$state.snapshot` To take a static snapshot of a deeply reactive `$state` proxy, use `$state.snapshot`:  This is handy when you want to pass some state to an external library or API that doesn't expect a proxy, such as `structuredClone`. ## `$derived` Derived state is declared with the `$derived` rune:  The expression inside `$derived` should be free of side-effects. Svelte will disallow state changes  inside derived expressions. As with `$state`, you can mark class fields as `$derived`. ## `$derived.by` Sometimes you need to create complex derivations that don't fit inside a short expression. In these cases, you can use `$derived.by` which accepts a function as its argument.  In essence, `$derived` is equivalent to `$derived.by => expression)`. ## Universal reactivity In the examples above, `$state` and `$derived` only appear at the top level of components. You can also use them within functions or even outside Svelte components inside `.svelte.js` or `.svelte.ts` modules.   There are a few things to note in the above example: - We're using getters to transport reactivity across the function boundary. This way we keep reactivity \"alive\". If we were to return the value itself, it would be fixed to the value at that point in time. This is no different to how regular JavaScript variables behave. - We're not destructuring the counter at the usage site. Because we're using getters, destructuring would fix `count` and `double` to the value at that point in time. To keep the getters \"alive\", we're not using destructuring. Again, this is how regular JavaScript works. If you have shared state you want to manipulate from various places, you don't need to resort to getters. Instead, you can take advantage of `$state` being deeply reactive and only update its properties, not the value itself: --- title: Side effects --- - `$effect`  - when not to use it, better patterns for what to do instead Side effects play a crucial role in applications. They are triggered by state changes and can then interact with external systems, like logging something, setting up a server connection or synchronize with a third-party library that has no knowledge of Svelte's reactivity model. ## `$effect` fundamentals To run _side-effects_ when the component is mounted to the DOM, and when values change, we can use the `$effect` rune ):  The function passed to `$effect` will run when the component mounts, and will re-run after any changes to the values it reads that were declared with `$state` or `$derived` . Re-runs are batched , and happen after any DOM updates have been applied. You can place `$effect` anywhere, not just at the top level of a component, as long as it is called during component initialization . It is then tied to the lifecycle of the component  and will therefore destroy itself when the component unmounts . You can return a function from `$effect`, which will run immediately before the effect re-runs, and before it is destroyed ).  ## `$effect` dependencies `$effect` automatically picks up any reactivy values  that are _synchronously_ read inside its function body and registers them as dependencies. When those dependencies change, the `$effect` schedules a rerun. Values that are read asynchronously — after an `await` or inside a `setTimeout`, for example — will _not_ be tracked. Here, the canvas will be repainted when `color` changes, but not when `size` changes ):  An effect only reruns when the object it reads changes, not when a property inside it changes. .)  An effect only depends on the values that it read the last time it ran. If `a` is true, changes to `b` will :  ## When not to use `$effect` In general, `$effect` is best considered something of an escape hatch — useful for things like analytics and direct DOM manipulation — rather than a tool you should use frequently. In particular, avoid using it to synchronise state. Instead of this...  ...do this:  > For things that are more complicated than a simple expression like `count * 2`, you can also use . You might be tempted to do something convoluted with effects to link one value to another. The following example shows two inputs for \"money spent\" and \"money left\" that are connected to each other. If you update one, the other should update accordingly. Don't use effects for this ):  Instead, use callbacks where possible ):  If you need to use bindings, for whatever reason , consider using getters and setters to synchronise state ):  If you absolutely have to update `$state` within an effect and run into an infinite loop because you read and write to the same `$state`, use . ## `$effect.pre` In rare cases, you may need to run code _before_ the DOM updates. For this we can use the `$effect.pre` rune:  Apart from the timing, `$effect.pre` works exactly like  — refer to its documentation for more info. ## `$effect.tracking` The `$effect.tracking` rune is an advanced feature that tells you whether or not the code is running inside a tracking context, such as an effect or inside your template ):  This allows you to  add things like subscriptions without causing memory leaks, by putting them in child effects. Here's a `readable` function that listens to changes from a callback function as long as it's inside a tracking context:  ## `$effect.root` The `$effect.root` rune is an advanced feature that creates a non-tracked scope that doesn't auto-cleanup. This is useful for nested effects that you want to manually control. This rune also allows for creation of effects outside of the component initialisation phase. --- title: Runes --- --- title: Stores --- - how to use - how to write - TODO should the details for the store methods belong to the reference section? A _store_ is an object that allows reactive access to a value via a simple _store contract_. The  contains minimal store implementations which fulfil this contract. Any time you have a reference to a store, you can access its value inside a component by prefixing it with the `$` character. This causes Svelte to declare the prefixed variable, subscribe to the store at component initialisation and unsubscribe when appropriate. Assignments to `$`-prefixed variables require that the variable be a writable store, and will result in a call to the store's `.set` method. Note that the store must be declared at the top level of the component — not inside an `if` block or a function, for example. Local variables  must _not_ have a `$` prefix.  ## When to use stores Prior to Svelte 5, stores were the go-to solution for creating cross-component reactive states or extracting logic. With runes, these use cases have greatly diminished. - when extracting logic, it's better to take advantage of runes' universal reactivity: You can use runes outside the top level of components and even place them into JavaScript or TypeScript files  - when creating shared state, you can create a `$state` object containing the values you need and manipulating said state Stores are still a good solution when you have complex asynchronous data streams or it's important to have more manual control over updating values or listening to changes. If you're familiar with RxJs and want to reuse that knowledge, the `$` also comes in handy for you. ## svelte/store The `svelte/store` module contains a minimal store implementation which fulfil the store contract. It provides methods for creating stores that you can update from the outside, stores you can only update from the inside, and for combining and deriving stores. ### `writable` Function that creates a store which has values that can be set from 'outside' components. It gets created as an object with additional `set` and `update` methods. `set` is a method that takes one argument which is the value to be set. The store value gets set to the value of the argument if the store value is not already equal to it. `update` is a method that takes one argument which is a callback. The callback takes the existing store value as its argument and returns the new value to be set to the store.  If a function is passed as the second argument, it will be called when the number of subscribers goes from zero to one . That function will be passed a `set` function which changes the value of the store, and an `update` function which works like the `update` method on the store, taking a callback to calculate the store's new value from its old value. It must return a `stop` function that is called when the subscriber count goes from one to zero.  Note that the value of a `writable` is lost when it is destroyed, for example when the page is refreshed. However, you can write your own logic to sync the value to for example the `localStorage`. ### `readable` Creates a store whose value cannot be set from 'outside', the first argument is the store's initial value, and the second argument to `readable` is the same as the second argument to `writable`.  ### `derived` Derives a store from one or more other stores. The callback runs initially when the first subscriber subscribes and then whenever the store dependencies change. In the simplest version, `derived` takes a single store, and the callback returns a derived value.  The callback can set a value asynchronously by accepting a second argument, `set`, and an optional third argument, `update`, calling either or both of them when appropriate. In this case, you can also pass a third argument to `derived` — the initial value of the derived store before `set` or `update` is first called. If no initial value is specified, the store's initial value will be `undefined`.  If you return a function from the callback, it will be called when a) the callback runs again, or b) the last subscriber unsubscribes.  In both cases, an array of arguments can be passed as the first argument instead of a single store.  ### `readonly` This simple helper function makes a store readonly. You can still subscribe to the changes from the original one using this new readable store.  ### `get` Generally, you should read the value of a store by subscribing to it and using the value as it changes over time. Occasionally, you may need to retrieve the value of a store to which you're not subscribed. `get` allows you to do so. > This works by creating a subscription, reading the value, then unsubscribing. It's therefore not recommended in hot code paths.  ## Store contract  You can create your own stores without relying on , by implementing the _store contract_: 1. A store must contain a `.subscribe` method, which must accept as its argument a subscription function. This subscription function must be immediately and synchronously called with the store's current value upon calling `.subscribe`. All of a store's active subscription functions must later be synchronously called whenever the store's value changes. 2. The `.subscribe` method must return an unsubscribe function. Calling an unsubscribe function must stop its subscription, and its corresponding subscription function must not be called again by the store. 3. A store may _optionally_ contain a `.set` method, which must accept as its argument a new value for the store, and which synchronously calls all of the store's active subscription functions. Such a store is called a _writable store_. For interoperability with RxJS Observables, the `.subscribe` method is also allowed to return an object with an `.unsubscribe` method, rather than return the unsubscription function directly. Note however that unless `.subscribe` synchronously calls the subscription , Svelte will see the value of the store as `undefined` until it does. --- title: Context --- - get/set/hasContext - how to use, best practises  Most state is component-level state that lives as long as its component lives. There's also section-wide or app-wide state however, which also needs to be handled somehow. The easiest way to do that is to create global state and just import that.   This has a few drawbacks though: - it only safely works when your global state is only used client-side - for example, when you're building a single page application that does not render any of your components on the server. If your state ends up being managed and updated on the server, it could end up being shared between sessions and/or users, causing bugs - it may give the false impression that certain state is global when in reality it should only used in a certain part of your app To solve these drawbacks, Svelte provides a few `context` primitives which alleviate these problems. ## Setting and getting context To associate an arbitrary object with the current component, use `setContext`.  The context is then available to children of the component  with `getContext`.  `setContext` and `getContext` solve the above problems: - the state is not global, it's scoped to the component. That way it's safe to render your components on the server and not leak state - it's clear that the state is not global but rather scoped to a specific component tree and therefore can't be used in other parts of your app > `setContext`/`getContext` must be called during component initialisation. Context is not inherently reactive. If you need reactive values in context then you can pass a `$state` object into context, whos properties _will_ be reactive.   To check whether a given `key` has been set in the context of a parent component, use `hasContext`.  You can also retrieve the whole context map that belongs to the closest parent component using `getAllContexts`. This is useful, for example, if you programmatically create a component and want to pass the existing context to it.  ## Encapsulating context interactions The above methods are very unopionated about how to use them. When your app grows in scale, it's worthwhile to encapsulate setting and getting the context into functions and properly type them. --- title: Lifecycle hooks --- - onMount/onDestroy - mention that `$effect` might be better for your use case - beforeUpdate/afterUpdate with deprecation notice? - or skip this entirely and only have it in the reference docs? In Svelte 5, the component lifecycle consists of only two parts: Its creation and its destruction. Everything in-between - when certain state is updated - is not related to the component as a whole, only the parts that need to react to the state change are notified. This is because under the hood the smallest unit of change is actually not a component, it's the  effects that the component sets up upon component initialization. Consequently, there's no such thing as a \"before update\"/\"after update\" hook. ## `onMount` The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM. It must be called during the component's initialisation . `onMount` does not run inside a component that is rendered on the server.  If a function is returned from `onMount`, it will be called when the component is unmounted.  > This behaviour will only work when the function passed to `onMount` _synchronously_ returns a value. `async` functions always return a `Promise`, and as such cannot _synchronously_ return a function. ## `onDestroy` > EXPORT_SNIPPET: svelte#onDestroy Schedules a callback to run immediately before the component is unmounted. Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the only one that runs inside a server-side component.  ## `tick` While there's no \"after update\" hook, you can use `tick` to ensure that the UI is updated before continuing. `tick` returns a promise that resolves once any pending state changes have been applied, or in the next microtask if there are none.  ## Deprecated: `beforeUpdate` / `afterUpdate` Svelte 4 contained hooks that ran before and after the component as a whole was updated. For backwards compatibility, these hooks were shimmed in Svelte 5 but not available inside components that use runes.  Instead of `beforeUpdate` use `$effect.pre` and instead of `afterUpdate` use `$effect` instead - these runes offer more granular control and only react to the changes you're actually interested in. ### Chat window example To implement a chat window that autoscrolls to the bottom when new messages appear , we need to measure the DOM before we update it. In Svelte 4, we do this with `beforeUpdate`, but this is a flawed approach — it fires before _every_ update, whether it's relevant or not. In the example below, we need to introduce checks like `updatingMessages` to make sure we don't mess with the scroll position when someone toggles dark mode. With runes, we can use `$effect.pre`, which behaves the same as `$effect` but runs before the DOM is updated. As long as we explicitly reference `messages` inside the effect body, it will run whenever `messages` changes, but _not_ when `theme` changes. `beforeUpdate`, and its equally troublesome counterpart `afterUpdate`, are therefore deprecated in Svelte 5. -  - --- title: Imperative component API --- better title needed? - mount - unmount - render - hydrate - how they interact with each other Every Svelte application starts by imperatively creating a root component. On the client this component is mounted to a specific element. On the server, you want to get back a string of HTML instead which you can render. The following functions help you achieve those tasks. ## `mount` Instantiates a component and mounts it to the given target:  You can mount multiple components per page, and you can also mount from within your application, for example when creating a tooltip component and attaching it to the hovered element. Note that unlike calling `new App` in Svelte 4, things like effects  will not run during `mount`. If you need to force pending effects to run  you can do so with `flushSync`. ## `unmount` Unmounts a component created with  or :  ## `render` Only available on the server and when compiling with the `server` option. Takes a component and returns an object with `body` and `head` properties on it, which you can use to populate the HTML when server-rendering your app:  ## `hydrate` Like `mount`, but will reuse up any HTML rendered by Svelte's SSR output  function) inside the target and make it interactive:  As with `mount`, effects will not run during `hydrate` — use `flushSync` immediately afterwards if you need them to. --- title: Runtime --- --- title: Debugging --- - `@debug` - `$inspect` Svelte provides two built-in ways to debug your application. ## `$inspect` The `$inspect` rune is roughly equivalent to `console.log`, with the exception that it will re-run whenever its argument changes. `$inspect` tracks reactive state deeply, meaning that updating something inside an object or array using fine-grained reactivity will cause it to re-fire. )  `$inspect` returns a property `with`, which you can invoke with a callback, which will then be invoked instead of `console.log`. The first argument to the callback is either `\"init\"` or `\"update\"`, all following arguments are the values passed to `$inspect`.   A convenient way to find the origin of some change is to pass `console.trace` to `with`:  > `$inspect` only works during development. In a production build it becomes a noop. ## @debug   The `{@debug ...}` tag offers an alternative to `console.log`. It logs the values of specific variables whenever they change, and pauses code execution if you have devtools open.  `{@debug ...}` accepts a comma-separated list of variable names .  The `{@debug}` tag without any arguments will insert a `debugger` statement that gets triggered when _any_ state changes, as opposed to the specified variables. --- title: Testing --- Testing helps you write and maintain your code and guard against regressions. Testing frameworks help you with that, allowing you to describe assertions or expectations about how your code should behave. Svelte is unopinionated about which testing framework you use — you can write unit tests, integration tests, and end-to-end tests using solutions like , ,  and . ## Unit and integration testing using Vitest Unit tests allow you to test small isolated parts of your code. Integration tests allow you to test parts of your application to see if they work together. If you're using Vite , we recommend using . To get started, install Vitest:  Then adjust your `vite.config.js`:  You can now write unit tests for code inside your `.js/.ts` files:  ### Using runes inside your test files It is possible to use runes inside your test files. First ensure your bundler knows to route the file through the Svelte compiler before running the test by adding `.svelte` to the filename . After that, you can use runes inside your tests.  If the code being tested uses effects, you need to wrap the test inside `$effect.root`:  ### Component testing It is possible to test your components in isolation using Vitest. > Before writing component tests, think about whether you actually need to test the component, or if it's more about the logic _inside_ the component. If so, consider extracting out that logic to test it in isolation, without the overhead of a component To get started, install jsdom :  Then adjust your `vite.config.js`:  After that, you can create a test file in which you import the component to test, interact with it programmatically and write expectations about the results:  While the process is very straightforward, it is also low level and somewhat brittle, as the precise structure of your component may change frequently. Tools like  can help streamline your tests. The above test could be rewritten like this:  When writing component tests that involve two-way bindings, context or snippet props, it's best to create a wrapper component for your specific test and interact with that. `@testing-library/svelte` contains some . ## E2E tests using Playwright E2E  tests allow you to test your full application through the eyes of the user. This section uses  as an example, but you can also use other solutions like  or . To get start with Playwright, either let you guide by , or install it from the command line using `npm init playwright`. It is also part of the setup CLI when you run `npm create svelte`. After you've done that, you should have a `tests` folder and a Playwright config. You may need to adjust that config to tell Playwright what to do before running the tests - mainly starting your application at a certain port:  You can now start writing tests. These are totally unaware of Svelte as a framework, so you mainly interact with the DOM and write assertions. --- title: TypeScript --- -  - built-in support, but only for type-only features - generics - using `Component` and the other helper types - using `svelte-check` You can use TypeScript within Svelte components. IDE extensions like the  will help you catch errors right in your editor, and  does the same on the command line, which you can integrate into your CI. ## `<script lang=\"ts\">` To use TypeScript inside your Svelte components, add `lang=\"ts\"` to your `script` tags:  Doing so allows you to use TypeScript's _type-only_ features. That is, all features that just disappear when transpiling to JavaScript, such as type annotations or interface declarations. Features that require the TypeScript compiler to output actual code are not supported. This includes: - using enums - using `private`, `protected` or `public` modifiers in constructor functions together with initializers - using features that are not yet part of the ECMAScript standard  and therefore not implemented yet within Acorn, the parser we use for parsing JavaScript If you want to use one of these features, you need to setup up a `script` preprocessor. ## Preprocessor setup To use non-type-only TypeScript features within Svelte components, you need to add a preprocessor that will turn TypeScript into JavaScript. ### Using SvelteKit or Vite The easiest way to get started is scaffolding a new SvelteKit project by typing `npm create svelte@latest`, following the prompts and choosing the TypeScript option.  If you don't need or want all the features SvelteKit has to offer, you can scaffold a Svelte-flavoured Vite project instead by typing `npm create vite@latest` and selecting the `svelte-ts` option.  In both cases, a `svelte.config.js` with `vitePreprocess` will be added. Vite/SvelteKit will read from this config file. ### Other build tools If you're using tools like Rollup or Webpack instead, install their respective Svelte plugins. For Rollup that's  and for Webpack that's . For both, you need to install `typescript` and `svelte-preprocess` and add the preprocessor to the plugin config . If you're starting a new project, you can also use the  or  template to scaffold the setup from a script. > If you're starting a new project, we recommend using SvelteKit or Vite instead ## Typing `$props` Type `$props` just like a regular object with certain properties.  ## Generic `$props` Components can declare a generic relationship between their properties. One example is a generic list component that receives a list of items and a callback property that reveives an item from the list. To declare that the `items` property and the `select` callback operate on the same types, add the `generics` attribute to the `script` tag:  The content of `generics` is what you would put between the `<...>` tags of a generic function. In other words, you can use multiple generics, `extends` and fallback types. ## Typing `$state` You can type `$state` like any other variable.  If you don't give `$state` an initial value, part of its types will be `undefined`.  If you know that the variable _will_ be defined before you first use it, use an `as` casting. This is especially useful in the context of classes:  ## The `Component` type Svelte components or of type `Component`. You can use it and its related types to express a variety of constraints. Using it together with `<svelte:component>` to restrict what kinds of component can be passed to it:  Closely related to the `Component` type is the `ComponentProps` type which extracts the properties a component expects.  ## Enhancing built-in DOM types Svelte provides a best effort of all the HTML DOM types that exist. Sometimes you may want to use experimental attributes or custom events coming from an action. In these cases, TypeScript will throw a type error, saying that it does not know these types. If it's a non-experimental standard attribute/event, this may very well be a missing typing from our . In that case, you are welcome to open an issue and/or a PR fixing it. In case this is a custom or experimental attribute/event, you can enhance the typings like this:  Then make sure that `d.ts` file is referenced in your `tsconfig.json`. If it reads something like `\"include\": ` and your `d.ts` file is inside `src`, it should work. You may need to reload for the changes to take effect. You can also declare the typings by augmenting the `svelte/elements` module like this: --- title: Custom elements --- -  Svelte components can also be compiled to custom elements  using the `customElement: true` compiler option. You should specify a tag name for the component using the `<svelte:options>` .  You can leave out the tag name for any of your inner components which you don't want to expose and use them like regular Svelte components. Consumers of the component can still name it afterwards if needed, using the static `element` property which contains the custom element constructor and which is available when the `customElement` compiler option is `true`.  Once a custom element has been defined, it can be used as a regular DOM element:  Any  are exposed as properties of the DOM element .  ## Component lifecycle Custom elements are created from Svelte components using a wrapper approach. This means the inner Svelte component has no knowledge that it is a custom element. The custom element wrapper takes care of handling its lifecycle appropriately. When a custom element is created, the Svelte component it wraps is _not_ created right away. It is only created in the next tick after the `connectedCallback` is invoked. Properties assigned to the custom element before it is inserted into the DOM are temporarily saved and then set on component creation, so their values are not lost. The same does not work for invoking exported functions on the custom element though, they are only available after the element has mounted. If you need to invoke functions before component creation, you can work around it by using the . When a custom element written with Svelte is created or updated, the shadow DOM will reflect the value in the next tick, not immediately. This way updates can be batched, and DOM moves which temporarily  detach the element from the DOM don't lead to unmounting the inner component. The inner Svelte component is destroyed in the next tick after the `disconnectedCallback` is invoked. ## Component options When constructing a custom element, you can tailor several aspects by defining `customElement` as an object within `<svelte:options>` since Svelte 4. This object may contain the following properties: - `tag: string`: an optional `tag` property for the custom element's name. If set, a custom element with this tag name will be defined with the document's `customElements` registry upon importing this component. - `shadow`: an optional property that can be set to `\"none\"` to forgo shadow root creation. Note that styles are then no longer encapsulated, and you can't use slots - `props`: an optional property to modify certain details and behaviors of your component's properties. It offers the following settings: - `attribute: string`: To update a custom element's prop, you have two alternatives: either set the property on the custom element's reference as illustrated above or use an HTML attribute. For the latter, the default attribute name is the lowercase property name. Modify this by assigning `attribute: \"<desired name>\"`. - `reflect: boolean`: By default, updated prop values do not reflect back to the DOM. To enable this behavior, set `reflect: true`. - `type: 'String' | 'Boolean' | 'Number' | 'Array' | 'Object'`: While converting an attribute value to a prop value and reflecting it back, the prop value is assumed to be a `String` by default. This may not always be accurate. For instance, for a number type, define it using `type: \"Number\"` You don't need to list all properties, those not listed will use the default settings. - `extend`: an optional property which expects a function as its argument. It is passed the custom element class generated by Svelte and expects you to return a custom element class. This comes in handy if you have very specific requirements to the life cycle of the custom element or want to enhance the class to for example use  for better HTML form integration.  ## Caveats and limitations Custom elements can be a useful way to package components for consumption in a non-Svelte app, as they will work with vanilla HTML and JavaScript as well as . There are, however, some important differences to be aware of: - Styles are _encapsulated_, rather than merely _scoped_ . This means that any non-component styles  will not apply to the custom element, including styles with the `:global` modifier - Instead of being extracted out as a separate .css file, styles are inlined into the component as a JavaScript string - Custom elements are not generally suitable for server-side rendering, as the shadow DOM is invisible until JavaScript loads - In Svelte, slotted content renders _lazily_. In the DOM, it renders _eagerly_. In other words, it will always be created even if the component's `<slot>` element is inside an `{#if ...}` block. Similarly, including a `<slot>` in an `{#each ...}` block will not cause the slotted content to be rendered multiple times - The deprecated `let:` directive has no effect, because custom elements do not have a way to pass data to the parent component that fills the slot - Polyfills are required to support older browsers - You can use Svelte's context feature between regular Svelte components within a custom element, but you can't use them across custom elements. In other words, you can't use `setContext` on a parent custom element and read that with `getContext` in a child custom element. --- title: Reactivity in depth --- - how to think about Runes  - signals --- title: Svelte 5 migration guide --- - the stuff from the preview docs and possibly more --- title: Misc --- --- title: $state --- TODO - add other pages - figure out a way to get separator titles in here, so we can have a 'runes' section and an 'imports' section and an 'errors/warnings' section without introducing another layer of nesting - figure out a good way to import reference docs from other repos that works locally and in prod --- title: svelte --- <!-- @include svelte --> --- title: svelte/action --- <!-- @include svelte/action --> --- title: svelte/animate --- <!-- @include svelte/animate --> --- title: svelte/compiler --- <!-- @include svelte/compiler --> --- title: svelte/easing --- <!-- @include svelte/easing --> --- title: svelte/events --- <!-- @include svelte/events --> --- title: svelte/legacy --- <!-- @include svelte/legacy --> --- title: svelte/motion --- <!-- @include svelte/motion --> --- title: svelte/reactivity --- <!-- @include svelte/reactivity --> --- title: svelte/server --- <!-- @include svelte/server --> --- title: svelte/store --- <!-- @include svelte/store --> --- title: svelte/transition --- <!-- @include svelte/transition --> --- title: Reference --- --- title: Svelte ---","timestamp":1725014817192}